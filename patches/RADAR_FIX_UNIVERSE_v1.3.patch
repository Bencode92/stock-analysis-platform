# PATCH pour portfolio_engine/universe.py
# Version: v1.3 RADAR TIE-BREAKER
#
# CORRECTIONS v1.3:
# - Coverage séparée: mapping vs tilt
# - Gate sur coverage_tilt (pas coverage_raw)
# - floor() au lieu de round() pour bucketisation
# - has_meaningful_radar() strict (tilt effectif uniquement)

# ============================================================================
# FIX #1: Ajouter AVANT "def sector_balanced_selection("
# ============================================================================

# =============================================================================
# v1.3: RADAR TIE-BREAKER HELPERS
# =============================================================================

def has_meaningful_radar(asset: dict) -> bool:
    """
    v1.3 STRICT: meaningful seulement si tilt EFFECTIF (favored/avoided).
    Un mapping non-vide sans tilt = inutile pour le tie-breaker.
    """
    m = asset.get("_radar_matching") or {}
    if not m:
        return False
    
    # Meaningful = tilt effectif uniquement
    return bool(
        m.get("sector_in_favored") or m.get("sector_in_avoided") or
        m.get("region_in_favored") or m.get("region_in_avoided")
    )


def _calibrate_eps(scores: List[float], fallback: float = 0.02) -> Dict[str, float]:
    """
    Calibre EPS (tie-band epsilon) de manière data-driven.
    
    Formule: EPS = max(0.005, 0.25 * std, IQR/20)
    Fallback si < 30 échantillons.
    """
    valid_scores = [s for s in scores if s is not None and not (isinstance(s, float) and math.isnan(s))]
    
    n = len(valid_scores)
    if n < 30:
        std_val = float(np.std(valid_scores)) if n > 1 else 0.0
        return {"eps": fallback, "std": std_val, "iqr": 0.0, "n": n, "method": "fallback"}
    
    arr = np.array(valid_scores, dtype=float)
    std_val = float(np.std(arr))
    q75, q25 = np.percentile(arr, [75, 25])
    iqr = float(q75 - q25)
    
    eps_std = 0.25 * std_val
    eps_iqr = iqr / 20.0 if iqr > 0 else 0.0
    eps = max(0.005, eps_std, eps_iqr)
    
    return {
        "eps": float(eps), 
        "std": std_val, 
        "iqr": iqr, 
        "n": n,
        "method": "data-driven",
    }


def _compute_radar_coverage(assets: List[dict]) -> Dict[str, Any]:
    """
    v1.3: Sépare coverage_mapping (normalisé) de coverage_tilt (effectif).
    Le gate tie-breaker utilise coverage_tilt.
    """
    total = len(assets)
    if total == 0:
        return {
            "total": 0, 
            "with_radar_key": 0,
            "with_mapping": 0,
            "with_tilt": 0,
            "coverage_raw": 0, 
            "coverage_mapping": 0,
            "coverage_tilt": 0,
        }
    
    with_radar_key = 0
    with_mapping = 0  # sector_normalized ou region_normalized non vide
    with_tilt = 0     # favored/avoided effectif (CELUI QUI COMPTE)
    
    for a in assets:
        m = a.get("_radar_matching") or {}
        if m:
            with_radar_key += 1
            
            # Mapping coverage (informatif)
            if m.get("sector_normalized") or m.get("region_normalized"):
                with_mapping += 1
            
            # Tilt coverage (pour gate) - STRICT
            if (m.get("sector_in_favored") or m.get("sector_in_avoided") or
                m.get("region_in_favored") or m.get("region_in_avoided")):
                with_tilt += 1
    
    return {
        "total": total,
        "with_radar_key": with_radar_key,
        "with_mapping": with_mapping,
        "with_tilt": with_tilt,
        "coverage_raw": round(with_radar_key / total, 4),
        "coverage_mapping": round(with_mapping / total, 4),
        "coverage_tilt": round(with_tilt / total, 4),  # ← GATE SUR CELUI-CI
    }


# ============================================================================
# FIX #2: Dans sector_balanced_selection(), utiliser floor() et coverage_tilt
# ============================================================================
#
# NOUVELLE SIGNATURE:
#
def sector_balanced_selection(
    assets: List[dict], 
    target_n: int = 25,
    initial_max_per_sector: int = 4,
    score_field: str = "composite_score",
    # v1.3: RADAR tie-breaker params
    enable_radar_tiebreaker: bool = True,
    radar_bonus_cap: float = 0.03,
    radar_min_coverage: float = 0.40,
    eps_fallback: float = 0.02,
    market_context: Optional[Dict] = None,
) -> Tuple[List[dict], Dict[str, Any]]:

# ============================================================================
# FIX #3: Dans la fonction de tri, utiliser math.floor() pas round()
# ============================================================================
#
    def sort_key_radar(a: dict):
        score = get_score(a)
        # v1.3: floor au lieu de round (comportement prévisible)
        bucket = math.floor(score / eps) if eps > 0 else 0
        radar = float(a.get("_radar_bonus", 0.0))
        aid = str(a.get("symbol") or a.get("id") or "").lower()
        return (-bucket, -radar, -score, aid)

# ============================================================================
# FIX #4: Gate sur coverage_tilt (pas coverage_raw)
# ============================================================================
#
    coverage_stats = _compute_radar_coverage(assets)
    
    # v1.3: Gate sur coverage_tilt (pas coverage_raw ni coverage_mapping)
    if enable_radar_tiebreaker and coverage_stats["coverage_tilt"] < radar_min_coverage:
        logger.warning(
            f"[RADAR] Désactivé: coverage_tilt {coverage_stats['coverage_tilt']:.1%} "
            f"< seuil {radar_min_coverage:.0%}. "
            f"(mapping={coverage_stats['coverage_mapping']:.1%}, "
            f"tilt={coverage_stats['with_tilt']}/{coverage_stats['total']})"
        )
        radar_active = False
        radar_disable_reason = f"coverage_tilt_too_low ({coverage_stats['coverage_tilt']:.1%})"
