# PATCH pour portfolio_engine/universe.py
# Version: v4.0.0 RADAR TIE-BREAKER
#
# Ce patch ajoute le tie-breaker RADAR à sector_balanced_selection()

# ============================================================================
# FIX #1: Ajouter AVANT "def sector_balanced_selection("
# ============================================================================

# =============================================================================
# v4.0.0: RADAR TIE-BREAKER HELPERS
# =============================================================================

def _calibrate_eps(scores: List[float], fallback: float = 0.02) -> Dict[str, float]:
    """
    Calibre EPS (tie-band epsilon) de manière data-driven.
    
    Formule: EPS = max(0.005, 0.25 * std, IQR/20)
    Fallback si < 30 échantillons.
    """
    valid_scores = [s for s in scores if s is not None and not (isinstance(s, float) and math.isnan(s))]
    
    n = len(valid_scores)
    if n < 30:
        std_val = float(np.std(valid_scores)) if n > 1 else 0.0
        return {"eps": fallback, "std": std_val, "iqr": 0.0, "n": n, "method": "fallback"}
    
    arr = np.array(valid_scores, dtype=float)
    std_val = float(np.std(arr))
    q75, q25 = np.percentile(arr, [75, 25])
    iqr = float(q75 - q25)
    
    eps_std = 0.25 * std_val
    eps_iqr = iqr / 20.0 if iqr > 0 else 0.0
    eps = max(0.005, eps_std, eps_iqr)
    
    return {
        "eps": float(eps), 
        "std": std_val, 
        "iqr": iqr, 
        "n": n,
        "method": "data-driven",
    }


def _compute_radar_coverage(assets: List[dict]) -> Dict[str, float]:
    """
    Calcule le taux de couverture _radar_matching.
    """
    total = len(assets)
    with_radar = sum(1 for a in assets if a.get("_radar_matching"))
    coverage = with_radar / max(1, total)
    
    return {
        "total": total,
        "with_radar": with_radar,
        "coverage": round(coverage, 4)
    }


# ============================================================================
# FIX #2: Modifier sector_balanced_selection() signature et logique
# ============================================================================
#
# NOUVELLE SIGNATURE:
#
def sector_balanced_selection(
    assets: List[dict], 
    target_n: int = 25,
    initial_max_per_sector: int = 4,
    score_field: str = "composite_score",
    # v4.0.0: RADAR tie-breaker params
    enable_radar_tiebreaker: bool = True,
    radar_bonus_cap: float = 0.03,
    radar_min_coverage: float = 0.40,
    eps_fallback: float = 0.02,
    market_context: Optional[Dict] = None,
) -> Tuple[List[dict], Dict[str, Any]]:

# VOIR tests/test_radar_tiebreaker.py pour implémentation complète
