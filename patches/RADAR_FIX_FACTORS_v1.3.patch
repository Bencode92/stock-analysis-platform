# PATCH pour portfolio_engine/factors.py
# Version: v1.3 RADAR TIE-BREAKER FIX
#
# CHANGEMENTS v1.3:
# - deepcopy DANS _build_lookups() (pas dans __init__)
# - Évite écrasement du deepcopy + mutation du global

# ============================================================================
# FIX #1: Ajouter import copy en haut du fichier (si pas déjà présent)
# ============================================================================

import copy

# ============================================================================
# FIX #2: Dans _build_lookups() - REMPLACER la ligne macro_tilts
# ============================================================================
#
# CHERCHER (dans _build_lookups):
#
        self._macro_tilts = self.market_context.get("macro_tilts", DEFAULT_MACRO_TILTS)
#
# REMPLACER PAR:
#
        # v3.1.3 FIX: deepcopy TOUJOURS pour éviter mutation du global
        tilts_src = self.market_context.get("macro_tilts") or DEFAULT_MACRO_TILTS
        self._macro_tilts = copy.deepcopy(tilts_src)

# ============================================================================
# FIX #3: Dans FactorScorer.__init__ - Appeler _build_lookups() TOUJOURS
# ============================================================================
#
# CHERCHER:
#
        if self.market_context:
            self._build_lookups()
#
# REMPLACER PAR:
#
        # v3.1.3: Appeler _build_lookups() TOUJOURS (gère le cas vide)
        self._build_lookups()

# ============================================================================
# FIX #4: Dans _build_lookups() - Ajouter log si market_context vide
# ============================================================================
#
# AU DÉBUT de _build_lookups(), après "def _build_lookups(self):", AJOUTER:
#
        if not self.market_context:
            logger.info(
                "FactorScorer: market_context vide → utilisation DEFAULT_MACRO_TILTS. "
                "_radar_matching sera calculé mais ne reflète pas le marché actuel."
            )

# ============================================================================
# FIX #5: Ajouter compute_radar_bonus_from_matching (avant if __name__)
# ============================================================================

# =============================================================================
# v3.1.3: RADAR BONUS HELPER (pour tie-breaker dans universe.py)
# =============================================================================

def compute_radar_bonus_from_matching(
    asset: dict,
    cap: float = 0.03,
    sector_trust_threshold: float = 0.6
) -> Tuple[float, Dict[str, Any]]:
    """
    Calcule le bonus RADAR à partir du _radar_matching existant.
    
    Ne recalcule PAS les tilts - utilise ce qui a été calculé par FactorScorer.
    Cela garantit la cohérence entre scoring et tie-breaker.
    
    Args:
        asset: Dictionnaire de l'actif avec _radar_matching
        cap: Bonus maximum (±cap)
        sector_trust_threshold: Seuil en dessous duquel on ignore le tilt ETF
        
    Returns:
        (bonus, metadata) où bonus est dans [-cap, +cap]
    """
    matching = asset.get("_radar_matching") or {}
    
    if not matching:
        return 0.0, {"reason": "no_radar_matching", "bonus": 0.0}
    
    # ETF: si sector_trust faible, ignorer (évite faux positifs type AAAU)
    sector_trust = asset.get("sector_trust")
    if sector_trust is not None and sector_trust < sector_trust_threshold:
        return 0.0, {
            "reason": "low_sector_trust", 
            "sector_trust": sector_trust,
            "threshold": sector_trust_threshold,
            "bonus": 0.0
        }
    
    # Calculer les "units" de bonus
    units = 0
    
    sector_tilt = matching.get("sector_tilt", "neutral")
    if sector_tilt == "favored":
        units += 1
    elif sector_tilt == "avoided":
        units -= 1
    
    # Région uniquement pour actions (ETFs n'ont pas de tilt géo fiable)
    category = asset.get("category", "").lower()
    region_tilt = matching.get("region_tilt", "neutral")
    
    if category == "equity":
        if region_tilt == "favored":
            units += 1
        elif region_tilt == "avoided":
            units -= 1
    
    # 1 unit = cap/2, 2 units = cap (max)
    unit_value = cap / 2.0
    bonus = max(-cap, min(cap, units * unit_value))
    
    metadata = {
        "units": units,
        "bonus": round(bonus, 6),
        "cap": cap,
        "sector_tilt": sector_tilt,
        "region_tilt": region_tilt if category == "equity" else "n/a (etf)",
        "category": category,
    }
    
    return bonus, metadata
