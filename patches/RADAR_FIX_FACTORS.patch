# PATCH pour portfolio_engine/factors.py
# Version: v3.1.0 RADAR TIE-BREAKER FIX
#
# Ce patch corrige le root cause: _macro_tilts=None quand market_context vide

# ============================================================================
# FIX #1: Dans FactorScorer.__init__ (ligne ~1290)
# ============================================================================
# 
# CHERCHER (ligne exacte):
#
        self._sector_lookup = None
        self._country_lookup = None
        self._macro_tilts = None
#
# REMPLACER PAR:
#
        self._sector_lookup = None
        self._country_lookup = None
        
        # v3.1.0 FIX CRITIQUE: Initialiser _macro_tilts avec DEFAULT
        # Garantit que _radar_matching sera TOUJOURS calculé
        self._macro_tilts = DEFAULT_MACRO_TILTS.copy()

# ============================================================================
# FIX #2: Dans FactorScorer.__init__ (après le bloc if)
# ============================================================================
#
# CHERCHER:
#
        if self.market_context:
            self._build_lookups()
#
# REMPLACER PAR:
#
        if self.market_context:
            self._build_lookups()
        else:
            # v3.1.0: Log warning si market_context vide
            logger.warning(
                "FactorScorer: market_context vide → utilisation DEFAULT_MACRO_TILTS. "
                "_radar_matching sera calculé mais ne reflète pas le marché actuel."
            )

# ============================================================================
# FIX #3: Ajouter avant "if __name__ == '__main__':" (fin du fichier)
# ============================================================================

# =============================================================================
# v3.1.0: RADAR BONUS HELPER (pour tie-breaker dans universe.py)
# =============================================================================

def compute_radar_bonus_from_matching(
    asset: dict,
    cap: float = 0.03,
    sector_trust_threshold: float = 0.6
) -> Tuple[float, Dict[str, Any]]:
    """
    Calcule le bonus RADAR à partir du _radar_matching existant.
    
    Ne recalcule PAS les tilts - utilise ce qui a été calculé par FactorScorer.
    Cela garantit la cohérence entre scoring et tie-breaker.
    
    Args:
        asset: Dictionnaire de l'actif avec _radar_matching
        cap: Bonus maximum (±cap)
        sector_trust_threshold: Seuil en dessous duquel on ignore le tilt ETF
        
    Returns:
        (bonus, metadata) où bonus est dans [-cap, +cap]
    """
    matching = asset.get("_radar_matching") or {}
    
    if not matching:
        return 0.0, {"reason": "no_radar_matching", "bonus": 0.0}
    
    # ETF: si sector_trust faible, ignorer (évite faux positifs type AAAU)
    sector_trust = asset.get("sector_trust")
    if sector_trust is not None and sector_trust < sector_trust_threshold:
        return 0.0, {
            "reason": "low_sector_trust", 
            "sector_trust": sector_trust,
            "threshold": sector_trust_threshold,
            "bonus": 0.0
        }
    
    # Calculer les "units" de bonus
    units = 0
    
    sector_tilt = matching.get("sector_tilt", "neutral")
    if sector_tilt == "favored":
        units += 1
    elif sector_tilt == "avoided":
        units -= 1
    
    # Région uniquement pour actions (ETFs n'ont pas de tilt géo fiable)
    category = asset.get("category", "").lower()
    region_tilt = matching.get("region_tilt", "neutral")
    
    if category == "equity":
        if region_tilt == "favored":
            units += 1
        elif region_tilt == "avoided":
            units -= 1
    
    # 1 unit = cap/2, 2 units = cap (max)
    unit_value = cap / 2.0
    bonus = max(-cap, min(cap, units * unit_value))
    
    metadata = {
        "units": units,
        "bonus": round(bonus, 6),
        "cap": cap,
        "sector_tilt": sector_tilt,
        "region_tilt": region_tilt if category == "equity" else "n/a (etf)",
        "category": category,
    }
    
    return bonus, metadata
